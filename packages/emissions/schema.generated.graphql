### This file is automatically generated ###

######## BEGIN IMPORTED DEFINITIONS ########

"""
An ERC20-compatible token
"""
type Token @entity {
    id: ID!

    """
    Token address
    """
    address: Bytes!

    """
    Token decimals
    """
    decimals: Int!

    """
    Token name
    """
    name: String!

    """
    Token symbol
    """
    symbol: String!

    """
    Total supply of the token
    """
    totalSupply: Metric!

    """
    Total quantity of tokens burned
    """
    totalBurned: Metric!

    """
    Total quantity of tokens minted
    """
    totalMinted: Metric!

    """
    Count of transfer transactions
    """
    totalTransfers: Counter!

    """
    Count of transfer transactions that minted the token
    """
    totalMints: Counter!

    """
    Count of transfer transactions that burned the token
    """
    totalBurns: Counter!
}

interface Transaction {
    """
    Transaction hash + log index
    """
    id: ID!

    """
    Transaction hash
    """
    hash: Bytes!

    """
    Block number the transaction is in
    """
    block: Int!

    """
    Timestamp of the block the transaction is in
    """
    timestamp: BigInt!

    """
    Address of the sender of the transaction
    """
    sender: Bytes!
}

type Metric @entity {
    id: ID!

    """
    Exact value of the metric, i.e. in base units as an integer
    """
    exact: BigInt!

    """
    Decimals used for the exact value (default: 18)
    """
    decimals: Int!

    """
    Simple value of the metric, i.e. the exact value represented as a decimal
    """
    simple: BigDecimal!
}

type Counter @entity {
    id: ID!

    """
    Value of the counter; should be positive
    """
    value: BigInt!
}

######### END IMPORTED DEFINITIONS #########



type EmissionsController @entity {
    """
    The ID is the address
    """
    id: ID!

    address: Bytes!

    """
    Address of rewards token. i.e. MTA token
    """
    rewardToken: Token!

    """
    List of staking contract addresses used to determine voting power
    """
    stakingContracts: [Bytes!]!

    """
    First weekly Epoch of this contract.
    """
    startEpoch: Epoch!

    """
    The last weekly Epoch to have rewards distributed.
    """
    lastEpoch: Epoch!

    """
    Dials for this Emissions Controller
    """
    dials: [Dial!]! @derivedFrom(field: "emissionsController")

    """
    Voters for this Emissions Controller
    """
    voters: [Voter!]! @derivedFrom(field: "emissionsController")

    """
    Epochs for this Emissions Controller
    """
    epochs: [Epoch!]! @derivedFrom(field: "emissionsController")
}

type Epoch @entity {
    """
    {emissionsController.id}.{weekNumber}
    """
    id: ID!

    """
    EmissionsController this Epoch belongs to
    """
    emissionsController: EmissionsController!

    """
    UNIX week number
    """
    weekNumber: Int!

    """
    Voters who last voted in this epoch
    """
    voters: [Voter!]! @derivedFrom(field: "lastEpoch")

    """
    Total from the top-level emissions for this Epoch
    """
    emission: BigInt!

    """
    DialVotesForEpoch for this Epoch; see "HistoricVotes" struct
    """
    dialVotes: [DialVotesForEpoch!]! @derivedFrom(field: "epoch")
}

type Dial @entity {
    """
    ID: {emissionsController.id}.{dialId}
    """
    id: ID!

    """
    Numeric dial ID (array position on EmissionsController dials)
    """
    dialId: Int!

    """
    Emissions Controller this Dial is part of
    """
    emissionsController: EmissionsController!

    """
    If true, no rewards are distributed to the dial
    recipient and any votes on this dial are ignored
    """
    disabled: Boolean!

    """
    Cap on distribution % where 1% = 1
    """
    cap: Int!

    """
    Dial rewards that are waiting to be distributed to recipient
    """
    balance: BigInt!

    """
    Account rewards are distributed to
    """
    recipient: Bytes!

    """
    Current Preferences for this Dial
    """
    preferences: [Preference!]! @derivedFrom(field: "dial")

    """
    DialVotesForEpoch for this Dial; see "HistoricVotes" struct
    """
    dialVotes: [DialVotesForEpoch!] @derivedFrom(field: "dial")
}

type DialVotesForEpoch @entity {
    """
    ID: {dial.id}.{epoch.id}
    """
    id: ID!

    dial: Dial!

    epoch: Epoch!

    """
    Number of votes directed to this Dial for this Epoch
    """
    votes: BigInt!
}

type Voter @entity {
    """
    ID: emissionsController.address
    """
    id: ID!

    address: Bytes!

    emissionsController: EmissionsController!

    """
    Latest tally of votes cast by this voter
    """
    votesCast: BigInt!

    """
    Last time balance was looked up across all staking contracts
    """
    lastSourcePoke: Int!

    """
    The last Epoch the Voter set Preferences for
    """
    lastEpoch: Epoch # TODO do we need this?

    """
    Preferences set by this Voter
    """
    preferences: [Preference!]! @derivedFrom(field: "voter")
}

type Preference @entity {
    """
    {voter.id}.{dial.id}
    """
    id: ID!

    voter: Voter!

    dial: Dial!

    """
    % weight applied to this dial, where 200 = 100% and 1 = 0.5%
    """
    weight: Int!
}
